# Shuyu

WPFと.NET 9で構築されたWindows向けの軽量で効率的なスクリーンキャプチャアプリケーションです。

## 📸 機能

- **スクリーンキャプチャ**: 画面の選択した領域を精密にキャプチャ
- **オーバーレイ選択**: キャプチャ範囲を選択するための直感的なオーバーレイインターフェース
- **システムトレイ統合**: 素早いアクセスのためにシステムトレイで静かに動作
- **ピン留めウィンドウ**: キャプチャした画像を簡単に参照できるようにピン留め
- **ホットキーサポート**: カスタマイズ可能なキーボードショートカットで素早くキャプチャ
- **マルチディスプレイ対応**: マルチモニター環境でシームレスに動作
- **デバッグログ**: トラブルシューティング用の内蔵ログシステム

## 🚀 はじめに

### 前提条件

- Windows 10/11
- .NET 9.0 Runtime

### インストール

1. [リリースページ](../../releases)から最新版をダウンロード
2. アーカイブを任意の場所に展開
3. `Shuyu.exe`を実行

### ソースからのビルド

```bash
git clone https://github.com/yourusername/Shuyu.git
cd Shuyu
dotnet build --configuration Release
```

## 🎯 使用方法

1. Shuyuを起動 - システムトレイに表示されます
2. トレイアイコンを右クリックしてオプションにアクセス：
   - **キャプチャ**: 新しいスクリーンキャプチャを開始
   - **設定**: アプリケーションの設定を構成
   - **終了**: アプリケーションを閉じる
3. キャプチャ中：
   - クリック＆ドラッグでキャプチャしたい領域を選択
   - 右クリックでキャンセル
   - キャプチャした画像は保存され、参照用にピン留めできます

## ⚙️ 設定

アプリケーションは設定を自動的に保存します。システムトレイメニューの設定ウィンドウから設定にアクセスできます。

## 🏗️ アーキテクチャ

- **WPFアプリケーション**: モダンなWindowsデスクトップアプリケーションフレームワーク
- **サービス層**: キャプチャ、ログ、システム統合のためのモジュラーサービス
- **非同期操作**: ノンブロッキングなスクリーンキャプチャとファイル操作
- **マルチDPI対応**: 異なるディスプレイスケーリングの適切な処理

### 主要コンポーネント

- `CaptureOverlayWindow`: 領域選択のためのフルスクリーンオーバーレイ
- `AsyncScreenCaptureService`: スクリーンキャプチャ操作を処理
- `TrayService`: システムトレイ統合とコンテキストメニュー
- `PinnedWindowManager`: ピン留めキャプチャウィンドウの管理
- `HotkeyManager`: グローバルホットキーの登録と処理

## 🤝 貢献

貢献を歓迎します！プルリクエストをお気軽に送信してください。大きな変更の場合は、まずissueを開いて変更したい内容について話し合ってください。

### 開発環境のセットアップ

1. リポジトリをクローン
2. Visual Studio 2022以降で`Shuyu.sln`を開く
3. プロジェクトをビルドして実行

## 📝 ライセンス

このプロジェクトはMITライセンスの下でライセンスされています - 詳細は[LICENSE](LICENSE)ファイルを参照してください。

## 🙏 謝辞

- WPFと.NET 9で構築
- 画像処理にSystem.Drawing.Commonを使用
- モダンなスクリーンキャプチャツールからインスピレーションを得る

## 📞 サポート

問題が発生した場合や質問がある場合は、GitHubで[issueを開いて](../../issues)ください。

## 🧪 DPI テスト自動化

このリポジトリには、ディスプレイの DPI（スケーリング）を考慮したスクリーンキャプチャの検証を自動化する PowerShell スクリプトが含まれています。

- スクリプト: `scripts\dpi_test.ps1`
- 目的: 複数モニタ・DPI 環境で、指定した矩形（DIP 単位）を実際にピクセル単位でキャプチャできるか検証します。モニタごとの DPI を順に取得し（多段フォールバック）、期待サイズと実際の画像サイズを比較します。

使い方:

```powershell
# ワークツリーのルートで実行
pwsh -File .\scripts\dpi_test.ps1 -OutDir .\artifacts\dpi-tests
```

出力:
- `artifacts\dpi-tests` に PNG ファイルを保存します（`virtual_full.png` など）。
- 実行ログに各矩形の期待ピクセルサイズと実際の取得サイズを表示します。

注意点:
- スクリプトは `GetDpiForMonitor`（`shcore.dll`）、`GetDpiForWindow`、`GetDeviceCaps`、`Graphics.DpiX/DpiY` の順で DPI を取得する多段フォールバックを実装していますが、環境や OS によって API の可用性が異なります。
- CI ランナーで実行する場合は GUI セッションが必要になるため、通常の GitHub Actions のホスト（ヘッドレス）では動作しません。Windows GUI を使える runner または専用 VM での実行を推奨します。
- 必要に応じて `-Verbose` フラグを付けると詳細な取得経路（どの API を使ったか）を確認できます。

改善案:
- CI での自動化を行う場合は、結果の PNG をアーティファクトとしてアップロードするワークフローを用意してください。

